---
layout:     post
title:      引擎开发笔记1 - 基础架构
subtitle:   用DX12做渲染玩具
date:       2021-11-18
author:     BY
header-img: 
catalog: true
tags:
    - 图形
    - 实战
    - DirectX12
    - 引擎开发
---
# 前言

想要开发一个渲染玩具来实践一些渲染知识，不过在学龙书的路上都是用着偏有针对性的（没泛用性）的程序结构，所以需要重新鼓捣一下。本来想着类似于**LearnOpenGL**那样去进一步的封装，比如说把贴图,**VBO**,根参数等全部都封装好，加个**stb**读纹理，加个**assimp**读模型，不过感觉又好像差点什么。

封装肯定是要的，但我不希望数据和操作跟渲染流程有过多的绑定，所以希望能有更进一步的抽象，就像**UE**那样可以直接调用不同的渲染**API**去绘制画面，把逻辑和渲染分开。这个我目前是觉得比较难以构思的，但如果要加上能对场景有控制的一些功能，比如说动态的载入模型，动作等，进一步的抽象肯定是必要的。

在实习的时候有幸接触过工业界的代码，由于目前确实在工程能力上比较弱，并不算特别明白各个不同的组件是怎么一起运行的，也不太明白这种软件应该如何架构。于是决定先跟着油管的**Cherno**大佬学习怎么进行引擎开发，虽然教学是**Opengl**,不过整体结构和思路应该差距不大。

# 正文

## 基础架构

### 引擎代码架构

读过游戏引擎框架的都知道，游戏引擎是特别复杂的，但单是一个渲染器来说，个人最想要注意的两个部分是：

1. **图形API封装**: 首先针对我的dx12,我应该去把所有的基础功能都封装起来。比如说根签名**CBO**等都应该能动态的通过简单的调用去设置当前渲染时要的数据。
2. **渲染器接口**: 既然我们封装好了**API**的基础功能，那么我应该在这之上去建立一个比较完善的**Render Loop**，通过调用包装好的**API**来实现不同的流水线功能。这里最好是把完整的一套例如**Shadow Mapping**, **Deferred Rendering**等功能都加上，然后根据需要去决定是否开启。

不过这是之后的事情，最主要还是要做出一个可以拓展的一个引擎框架出来。这里参考了教学里面的做法，把整个引擎和我们要去使用引擎的程序分开来，变成下面两个部分：

1. 以**DLL**形式存在的引擎
2. 以**exe**形式存在的前端程序

##### DLL形式的引擎和exe前端

实际上用单个**Project(exe)**做一个渲染器也是可以的，不过这样的分配法也让引擎本身更加的独立于用户的自定义操作。试着去把**Application**跟**Engine**分开可以更加的了解怎么样编写引擎可以提供更多的空间给使用引擎的程序，这自然是件好事。

就像**DX12龙书**的设计一样，引擎内部需要一个**Application**的原型，这样可以保证整个引擎本身的运行流程，并且决定继承自自己的程序应该拥有多大程度的操作。我们首先需要在引擎内部有一个应用类，然后通过在外部继承的应用子类去自定义部分的逻辑来运行引擎：

![](/img/in-post/engine/Application.png)

这里我们还不太需要考虑到继承后的程序应该做什么，目前首先要确保的是引擎的运行流程。

### 引擎运行流程

引擎内部的设计应该也是跟着经典的 **初始化->更新(接消息->处理消息)** 方式进行。

为了控制整个流程，也就是所有子系统的初始化和更新的同步，我们会使用上方提到的**Application**类去控制所有行为的同步。这里只是一个初步的设想，实际运作和构造应该还是有一些些差距。

![](/img/in-post/engine/engineloop.png)

在目前的比较初期的开发阶段，最需要注意的是以下三个子系统。

1. **Log系统**
2. **窗口系统**
3. **消息系统**

## LOG系统

### **spdlog**

**Log系统**应该是最需要优先考虑的。我们在开发的过程中一定会出一大堆问题，如果没有**Log**的话**Debug**起来难度实在会太高。

这里首先是建立了一个中间类来更方便的调用我们的**Log**，在类内部建立两个静态的**Logger**实例。一个是用于表示我们的**dll**，一个是前端程序。这里会根据编译的环境来选择使用哪一个记录器：

![](/img/in-post/engine/logger.png)



## 窗口

### 窗口和DX12

窗口的话因为我想使用**DX12**来做简单的渲染器，所以窗口就是一个普通的**Win32**窗口。在窗口类的设计上其实不太需要去考虑和**渲染API**之间耦合不耦合，我没有任何理由去设计一个可以搭**DX12和Opengl**的窗口，毕竟两者之间的绑定是很深的**(还有就是GL系列都可以glfw)**。因此在这里实际上是在写一个**DX12Window**类。

所以窗口这里的工作是初始化窗口，然后初始化**DX12**。

### 消息

由于我们的窗口类他只是一个子系统，所以我们在设计上不能在窗口的 **MainWndProc()** 这里对操作进行太多的干涉。窗口系统内部只是提供了消息的输入的口，不提供我们本身对信息的回应。所以这里在接收消息后会转接给消息系统来处理。

顺便一提整个**win32**窗口的流程是这样子的：

![](/img/in-post/engine/win32msgpipeline.png)

1. **Peek**： 运行时会反复的查看硬件那里是否有新的消息过来
2. **Translate**: 这是一个可选项，实际上做的就是把我们键盘相关的消息，比如**WM_KEYDOWN**，翻译成**WM_CHAR**后塞进我们的消息队列。如果我们需要用到实际的**ASCII**字符才需要把这个环节启动。还有就是如果调用了**Translate**，那么一次的**KEYDOWN**消息会变成两个消息(**KEYDOWN + CHAR**)
3. **Dispatch**: 这个环节就是把我们目前排在队列中的消息，转发到我们在建立窗口时绑定了的**MsgProc**函数去处理。如果没有**Dispatch**那么消息就转发不到窗口侧
4. **MsgProc**： 这里需要写我们针对每个不同的消息应该怎么处理



## 消息系统

### 介绍

之前在学**DX12龙书**的时候不会特别去注意这一部分，因为在实现单独功能的时候，我们可以直接的去对系统传递到窗口的任意消息去自定义操作。但如果我们想要降低依赖性来让引擎更加的 独立， 那么我们就需要自己去制定一个消息系统。

首先目标就是让窗口侧的信息处理只负责收信息然后转发到我们的引擎主程序，所以这里的消息系统比起一个实际上存在的中间件(**含有.h和.cpp的类**),更像是对信息的包装。

这里主要有两个工作要做：

1. 把信息进行归类，让从窗口侧传到引擎主程序后，主程序可以更舒适的处理这些信息。
2. 设法让窗口能把信息传到主程序



###  分类

这里我们把所有的消息通过两个层级来处理，首先我们判断消息属于哪一种大类**Category**，然后再细分成具体操作。这样我们后面的处理会更加的灵活。之后只需要把两个**Enum**包装为一个消息的数据结构就可以了。

![](/img/in-post/engine/Eventcategory.png)

实际转发的时候就是针对每一个窗口接收的消息类型，在窗口内部打包成对应的数据结构后转发。

![](/img/in-post/engine/msgstruct.png)

### 传递和委托

我们在这个阶段最主要的工作，就是在窗口处理消息的时候把对应的消息传送给应用。这里一个很简单的想法就是，在窗口处理每个消息的时候，去调用应用那里的接收函数，并且把消息本身当成参数传递。

简单来说就是:

```
LRESULT Window::MsgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
		switch (msg)
		{
			case WM_KEYDOWN:
			    Create Keydown Event e;
			    Application.OnEvent(e);
			    return 0;
		}
		return 0;
	}
```

这种感觉。不过这样的设计有个小问题：

- **窗口是在应用内的**：在设计和运行两方面去考虑，我们都是**应用含有一个窗口**这么一个思路，也就是窗口是应用的一个组件。 那么这里的消息传递就是把一个内部的消息传到父级组件里的行为。但是我们的窗口不应该能直接调用父级组件的函数，这样的设计不太合理。通俗点说就是这样需要让窗口持有应用的指针，但这种互相依赖的设计并不适合。

因此这里比起对父级组件的调用，我们应该给窗口类设置一个委托(**函数指针 std::function**)，然后在应用那一侧去指定消息的回调函数。这样解决了一个互相依赖的耦合问题，代码上也比较好看。还有就是虽然不太确定，但根据网上的信息来看委托确实比直接对对象的函数调用比较快，尤其是在信息处理这种需要频繁调用的情况。

因此最后我们的应用流程变成：



# 学到的小知识

##### 宏的使用

我的客户端侧肯定是要调用引擎侧的函数，要从动态链接库输出的函数需要打上 **__declspec(dllexport)**宏，然后在客户端侧如果需要用到这个函数，需要声明一个相同的函数并且打上 **__declspec(dllimport)**宏。

当然，上面这个操作是很繁琐的，这相当于对于每个需要用到的函数，我都需要在**DLL**侧声明一次带宏的，然后在客户端侧进行一样的操作。这个问题可以通过再外接一层宏来解决，这里是这么处理的：

1. 首先，我们先外接一层宏，取名叫**Core.h**，这个宏把繁琐的 **__declspec(dllexport)**替换成了**FOO_API**

2. 接下来，我们在这一层宏里面设置一个关键的条件：**如果是动态库那里在加载FOO_API,就把他替换成export，  如果是客户端在加载FOO_API，就替换成import**

3. 这里决定是哪一侧在读这一层宏的就是我们可以在设定里找到的**Preprocessor**里面的参数。如果我有添加我**#ifdef**的东西，那么这里会指向上面的内容，如果我这一侧没设，就会指向下面。

   ![](/img/in-post/engine/core_h.png)



通过上面的操作，我们只需要**include**这一层封装，就可以让两侧的代码共享相同的头文件， 可喜可贺。

##### 程序入口

这里的架构是这样的，引擎**DLL**有一个**Application**类，并且客户端这里有一个继承自它的子类。我们想当然会把程序的**main**放在客户端这里，但这里大佬没有这么做。这里我们是要确保两点，就是引擎有明确的入口，程序也有明确的入口，通过在引擎侧在一个头文件里面写入**main**就可以达到这个效果，当然设计方式有很多，并不一定需要这么做。

客户端本身是没有入口的，只有在加载了**DLL**后，才会在头文件里面读到这个**main**然后运行。

![](/img/in-post/engine/mainentry.png)

##### Pre-compiled Header

有很多官方的库比如说**std**是会被我们经常使用的。如果我们很多的文档都去**include**比如**std::string**库的话，我们每次编译都要花大把时间去编译这些不会被我们改动的库。使用**PCH**的话我们可以把我们不会去改动的官方库提前进行编译后储存起来，这样之后每次要编译项目的时候都不需要去花时间编译这些了。

